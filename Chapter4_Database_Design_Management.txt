CHAPTER 4: DATABASE DESIGN AND MANAGEMENT

4.1 Database Overview and Architecture

The Hospital Management System (HMS) implements a sophisticated hybrid database architecture known as Polyglot Persistence, which strategically leverages both relational (SQL) and non-relational (NoSQL) database technologies to optimize data storage, retrieval, and management across different service domains. This architectural decision was made to address the diverse data requirements inherent in healthcare systems, where structured transactional data coexists with flexible, semi-structured medical records.

The system utilizes PostgreSQL 15 Alpine as the primary relational database management system for structured data requiring ACID compliance, while MongoDB 7.0 serves as the document database for flexible schema requirements. This dual-database approach ensures optimal performance, scalability, and data integrity across all system components.

4.1.1 Database Selection Rationale

PostgreSQL was selected as the primary relational database due to its robust ACID compliance, advanced indexing capabilities, support for JSON data types, and excellent performance characteristics. The system specifically uses PostgreSQL 15 Alpine for its lightweight footprint and enhanced security features.

MongoDB was chosen for document storage due to its flexible schema design, native JSON support, horizontal scaling capabilities, and excellent performance for read-heavy workloads typical in medical record retrieval systems.

4.1.2 Database Distribution Strategy

The system implements a microservices-oriented database distribution strategy where each service maintains its dedicated database instance, ensuring loose coupling and independent scalability. The current implementation includes eight specialized databases:

- Authentication Database (hms_auth_db): User authentication and authorization
- Appointment Scheduling Database (hms_appointment_db): Appointment management
- Patient Management Database (hms_patient_db): Patient demographic information
- Doctor Management Database (hms_doctor_db): Healthcare provider information
- Electronic Health Records Database (hms_ehr_db): Audit logs and metadata
- Billing Database (hms_billing_db): Financial transactions and billing
- Pharmacy Database (hms_pharmacy_db): Prescription and medication management
- Medical History Database (hms_medical_history_db): Patient medical records in MongoDB

4.2 Relational Database Schema Design (PostgreSQL)

4.2.1 Authentication Service Schema

The authentication service implements a sophisticated user management system with role-based access control (RBAC). The schema consists of two primary tables:

Users Table Structure:
- id (BIGSERIAL PRIMARY KEY): Auto-incrementing unique identifier
- username (VARCHAR(255) NOT NULL UNIQUE): Unique username for system access
- password (VARCHAR(255) NOT NULL): BCrypt encrypted password hash
- email (VARCHAR(255) NOT NULL): User email address for communication

User Roles Table Structure:
- user_id (BIGINT NOT NULL): Foreign key reference to users table
- roles (VARCHAR(255) NOT NULL): Role designation (ROLE_ADMIN, ROLE_DOCTOR, ROLE_PATIENT, ROLE_NURSE, ROLE_RECEPTIONIST)

The authentication system supports multiple role assignments per user, enabling flexible permission management. For example, senior doctors can have both ROLE_DOCTOR and ROLE_ADMIN privileges.

4.2.2 Patient Management Schema

The patient management service maintains comprehensive demographic and administrative patient information:

Patients Table Structure:
- id (BIGSERIAL PRIMARY KEY): Unique patient identifier
- user_id (BIGINT): Reference to authentication system
- first_name, last_name (VARCHAR(255) NOT NULL): Patient name fields
- email (VARCHAR(255)): Contact email address
- date_of_birth (DATE): Patient birth date for age calculations
- marital_status (VARCHAR(50)): Marital status information
- treatment (VARCHAR(255) NOT NULL): Current treatment description
- gender (VARCHAR(10) NOT NULL): Gender with constraint validation
- mobile (VARCHAR(20) NOT NULL): Primary contact number
- admission_date (DATE NOT NULL): Hospital admission date
- doctor_assigned (VARCHAR(255) NOT NULL): Assigned healthcare provider
- address (TEXT NOT NULL): Complete patient address
- blood_group (VARCHAR(5) NOT NULL): Blood type with validation constraints
- discharge_date (DATE): Hospital discharge date
- status (VARCHAR(50) NOT NULL): Patient status (Admitted, Discharged, Under Observation)
- created_at, updated_at (TIMESTAMP): Audit trail timestamps

4.2.3 Doctor Management Schema

The doctor management service stores comprehensive healthcare provider information:

Doctors Table Structure:
- id (BIGSERIAL PRIMARY KEY): Unique doctor identifier
- first_name, last_name (VARCHAR(255) NOT NULL): Doctor name fields
- email (VARCHAR(255) NOT NULL UNIQUE): Unique email address
- mobile (VARCHAR(20) NOT NULL): Contact phone number
- license_number (VARCHAR(50) NOT NULL UNIQUE): Medical license identifier
- specialization (VARCHAR(50) NOT NULL): Medical specialization with enumerated constraints
- experience_years (INTEGER NOT NULL): Years of medical practice
- qualification (VARCHAR(255) NOT NULL): Educational credentials
- date_of_birth (DATE NOT NULL): Doctor's birth date
- gender (VARCHAR(10) NOT NULL): Gender information
- hire_date (DATE NOT NULL): Employment start date
- status (VARCHAR(20) NOT NULL DEFAULT 'ACTIVE'): Employment status
- consultation_fee (DECIMAL(10, 2) NOT NULL): Consultation charges
- bio (TEXT): Professional biography
- created_at, updated_at (TIMESTAMP): Audit timestamps

The specialization field includes comprehensive validation constraints supporting fifteen medical specialties including General Practice, Cardiology, Neurology, Orthopedics, Pediatrics, Dermatology, Gynecology, Emergency Medicine, Radiology, Psychiatry, Surgery, Oncology, Endocrinology, Gastroenterology, and Pulmonology.

4.2.4 Appointment Scheduling Schema

The appointment management system handles complex scheduling requirements:

Appointments Table Structure:
- id (BIGSERIAL PRIMARY KEY): Unique appointment identifier
- patient_name (VARCHAR(255) NOT NULL): Patient identification
- doctor (VARCHAR(255) NOT NULL): Assigned healthcare provider
- gender (VARCHAR(10) NOT NULL): Patient gender with validation
- appointment_date (DATE NOT NULL): Scheduled appointment date
- appointment_time (TIME NOT NULL): Scheduled appointment time
- mobile (VARCHAR(20) NOT NULL): Contact information
- injury (VARCHAR(500)): Reason for visit description
- email (VARCHAR(255) NOT NULL): Patient email address
- appointment_status (VARCHAR(20) NOT NULL): Status tracking
- visit_type (VARCHAR(30) NOT NULL): Visit categorization
- created_at, updated_at (TIMESTAMP): Audit trail

The appointment status field supports six states: SCHEDULED, CONFIRMED, CANCELLED, COMPLETED, PENDING, and RESCHEDULED. Visit types include ROUTINE_CHECKUP, NEW_PATIENT_VISIT, FOLLOW_UP, CONSULTATION, and URGENT_CARE.

4.2.5 Billing and Financial Management Schema

The billing service implements a comprehensive financial management system with multiple interconnected tables:

Billing Items Master Table:
- id (SERIAL PRIMARY KEY): Unique item identifier
- item_code (VARCHAR(50) UNIQUE NOT NULL): Standardized billing code
- description (TEXT NOT NULL): Service description
- category (VARCHAR(50) NOT NULL): Service categorization
- unit_price (DECIMAL(10,2) NOT NULL): Service pricing
- is_active (BOOLEAN DEFAULT true): Active status flag
- created_at, updated_at (TIMESTAMP): Audit timestamps

The system categorizes billing items into five primary categories: CONSULTATION, PROCEDURE, MEDICATION, LAB_TEST, and ROOM_CHARGE, with over 20 predefined billing items including consultations, diagnostic procedures, laboratory tests, room charges, and common medications.

Insurance Companies Table:
- id (SERIAL PRIMARY KEY): Unique insurance provider identifier
- company_name (VARCHAR(255) UNIQUE NOT NULL): Insurance company name
- contact_email, contact_phone (VARCHAR): Contact information
- default_coverage_percentage (DECIMAL(5,2)): Standard coverage rate
- default_copay_amount (DECIMAL(10,2)): Standard copayment amount
- is_active (BOOLEAN DEFAULT true): Active status

Patient Insurance Table:
- id (SERIAL PRIMARY KEY): Unique policy identifier
- patient_id (BIGINT NOT NULL): Patient reference
- insurance_company_id (INTEGER): Insurance provider reference
- policy_number (VARCHAR(100) NOT NULL): Insurance policy number
- coverage_percentage (DECIMAL(5,2)): Individual coverage rate
- copay_amount (DECIMAL(10,2)): Individual copayment
- deductible (DECIMAL(10,2)): Annual deductible amount
- max_coverage (DECIMAL(12,2)): Maximum coverage limit
- policy_start_date, policy_end_date (DATE): Policy validity period

Payment Methods Table:
- id (SERIAL PRIMARY KEY): Payment method identifier
- method_name (VARCHAR(50) UNIQUE NOT NULL): Payment type
- description (TEXT): Method description
- processing_fee_percentage (DECIMAL(5,4)): Transaction fees

The system supports six payment methods: CASH, CREDIT_CARD, DEBIT_CARD, INSURANCE, BANK_TRANSFER, and CHECK, each with associated processing fees.

4.2.6 Pharmacy Management Schema

The pharmacy service manages prescription and medication data:

Prescriptions Table:
- id (BIGSERIAL PRIMARY KEY): Unique prescription identifier
- prescription_number (VARCHAR(50) NOT NULL UNIQUE): Prescription reference
- patient_id (BIGINT NOT NULL): Patient reference
- patient_name (VARCHAR(100) NOT NULL): Patient identification
- doctor_id (BIGINT NOT NULL): Prescribing physician reference
- doctor_name (VARCHAR(100) NOT NULL): Physician identification
- prescribed_date (DATE NOT NULL): Prescription date
- dispensed_date (DATE): Medication dispensing date
- status (VARCHAR(20) NOT NULL DEFAULT 'PENDING'): Prescription status
- total_amount (DECIMAL(10,2)): Prescription cost
- notes (TEXT): Additional prescription notes
- created_at, updated_at (TIMESTAMP): Audit timestamps

4.3 Document Database Schema Design (MongoDB)

4.3.1 Medical History Collection Structure

The MongoDB implementation stores flexible medical history data that accommodates varying patient information structures:

Medical History Document Schema:
- _id (ObjectId): MongoDB document identifier
- patient_id (Long): Reference to PostgreSQL patient record
- height (Double): Patient height measurement
- weight (Double): Patient weight measurement
- allergies (Array[String]): Known patient allergies
- past_conditions (Array[String]): Historical medical conditions
- surgeries (Array[Object]): Surgical history with embedded documents
  - surgery (String): Surgery description
  - date (Date): Surgery date
  - notes (String): Additional surgery notes
- medications (Array[Object]): Current medications with embedded documents
  - medication (String): Medication name
  - dosage (String): Prescribed dosage
  - frequency (String): Administration frequency
  - startDate (Date): Medication start date
  - endDate (Date): Medication end date
  - notes (String): Medication notes
- created_at, updated_at (Date): Document timestamps

4.3.2 EHR Reports Collection

The Electronic Health Records service utilizes MongoDB for storing comprehensive medical reports:

EHR Report Document Structure:
- _id (ObjectId): Unique report identifier
- patient_id (Long): Patient reference
- doctor_id (Long): Attending physician reference
- report_type (String): Report categorization
- report_date (Date): Report generation date
- vital_signs (Object): Embedded vital signs data
- diagnosis (Array[String]): Medical diagnoses
- treatment_plan (Array[Object]): Treatment recommendations
- lab_results (Array[Object]): Laboratory test results
- imaging_results (Array[Object]): Medical imaging results
- notes (String): Physician notes
- created_at, updated_at (Date): Audit timestamps

4.3.3 Billing Transaction History

The billing service uses MongoDB for storing detailed transaction histories:

Billing Transaction Document Structure:
- _id (ObjectId): Transaction identifier
- patient_id (Long): Patient reference
- bill_id (Long): Associated bill reference
- transaction_items (Array[Object]): Detailed billing items
- payment_history (Array[Object]): Payment transaction records
- insurance_claims (Array[Object]): Insurance claim information
- audit_trail (Array[Object]): Transaction modification history

4.4 Database Performance Optimization and Indexing Strategy

4.4.1 PostgreSQL Indexing Strategy

The system implements comprehensive indexing strategies to optimize query performance:

Primary Indexes:
- B-tree indexes on primary keys (automatic)
- Unique indexes on email fields and license numbers
- Composite indexes on frequently queried combinations

Specialized Indexes:
- Users table: idx_users_username, idx_users_email
- Patient table: idx_patients_status, idx_patients_admission_date, idx_patients_doctor_assigned, idx_patients_blood_group
- Appointments table: idx_appointments_date, idx_appointments_status, idx_appointments_doctor
- Billing table: idx_billing_items_category, idx_patient_insurance_patient_id

4.4.2 MongoDB Indexing Strategy

MongoDB collections utilize strategic indexing for optimal document retrieval:

Medical History Indexes:
- Unique index on patient_id for fast patient lookups
- Compound indexes on created_at and updated_at for temporal queries
- Multikey indexes on allergies and past_conditions arrays
- Text indexes on surgery and medication notes for search functionality

4.4.3 Connection Pool Management

The system implements sophisticated connection pooling strategies:

PostgreSQL Connection Pool Configuration:
- Maximum pool size: 10 connections per service
- Minimum idle connections: 5
- Connection timeout: 30 seconds
- Connection validation and health checks

MongoDB Connection Configuration:
- Auto-index creation enabled
- Connection URI-based configuration
- Replica set support for high availability

4.5 Data Security and Compliance

4.5.1 Data Encryption and Protection

The system implements multiple layers of data protection:

At-Rest Encryption:
- PostgreSQL: Transparent Data Encryption (TDE) for sensitive fields
- MongoDB: Field-level encryption for PHI data
- Password encryption: BCrypt hashing with salt rounds

In-Transit Encryption:
- TLS 1.3 encryption for all database connections
- Certificate-based authentication
- Encrypted backup and replication channels

4.5.2 Audit Trail Implementation

Comprehensive audit logging is implemented across all database operations:

PostgreSQL Audit Tables:
- EHR access logs with user tracking
- Data modification timestamps
- Login attempt logging
- Administrative action tracking

MongoDB Change Streams:
- Real-time change detection
- Document modification history
- User access pattern analysis

4.5.3 HIPAA Compliance Measures

The database design incorporates HIPAA compliance requirements:

Technical Safeguards:
- Role-based access control implementation
- Minimum necessary access principles
- Automatic session timeout mechanisms
- Encryption of PHI data elements

Administrative Safeguards:
- User access management procedures
- Regular access reviews and audits
- Incident response procedures
- Data backup and recovery protocols

4.6 Database Deployment and Environment Management

4.6.1 Containerized Database Deployment

The system utilizes Docker containerization for database deployment:

PostgreSQL Container Configuration:
- Image: postgres:15-alpine
- Persistent volume mapping
- Health check implementation
- Network isolation and security

MongoDB Container Configuration:
- Image: mongo:7.0
- Replica set configuration
- Persistent storage volumes
- Authentication and authorization

4.6.2 Development Environment Setup

The system provides multiple deployment options:

Docker Compose Deployment:
- Automated database creation
- Sample data population
- Service orchestration
- Network configuration

Local Development Scripts:
- Individual database setup scripts
- Incremental migration support
- Test data population
- Performance optimization

4.6.3 Configuration Management

Centralized configuration management through Spring Cloud Config:

Environment-Specific Configurations:
- Development environment settings
- Docker deployment configurations
- Production-ready parameters
- Security credential management

4.7 Database Backup and Disaster Recovery

4.7.1 Backup Strategy Implementation

The system implements comprehensive backup strategies:

PostgreSQL Backup Procedures:
- Automated daily full backups
- Continuous WAL archiving
- Point-in-time recovery capability
- Cross-region backup replication

MongoDB Backup Procedures:
- Automated daily collection snapshots
- Incremental backup support
- Replica set backup coordination
- Cloud storage integration

4.7.2 Disaster Recovery Planning

Comprehensive disaster recovery procedures:

Recovery Time Objectives (RTO):
- Critical systems: 15 minutes
- Standard systems: 1 hour
- Development systems: 4 hours

Recovery Point Objectives (RPO):
- Transaction data: 5 minutes
- Clinical data: 15 minutes
- Administrative data: 1 hour

4.8 Database Monitoring and Maintenance

4.8.1 Performance Monitoring

Real-time database performance monitoring:

PostgreSQL Monitoring:
- Query performance analysis
- Connection pool utilization
- Resource consumption tracking
- Slow query identification

MongoDB Monitoring:
- Collection performance metrics
- Index utilization analysis
- Memory usage optimization
- Replication lag monitoring

4.8.2 Maintenance Procedures

Regular database maintenance activities:

Automated Maintenance Tasks:
- Index rebuilding and optimization
- Statistics updates
- Log file rotation
- Unused data archival

Manual Maintenance Tasks:
- Schema migration procedures
- Performance tuning optimization
- Security patch application
- Capacity planning analysis

4.9 Entity-Relationship Diagram (ERD)

The system's Entity-Relationship Diagram illustrates the complex relationships between database entities:

Central Entity Relationships:
- Users table serves as the central authentication hub
- One-to-one relationship between users and doctors (for ROLE_DOCTOR users)
- One-to-many relationship from roles to users through user_roles junction table
- Many-to-many relationships resolved through junction tables for appointments

Cross-Service Relationships:
- Patient management service references authentication users
- Appointment scheduling links patients and doctors
- Billing service correlates with patient and doctor services
- Medical history documents reference PostgreSQL patient IDs

The ERD demonstrates the sophisticated data architecture supporting the hospital management system's comprehensive functionality while maintaining data integrity and optimal performance across all service domains.

This hybrid database architecture ensures scalable, secure, and efficient data management capabilities essential for modern healthcare information systems, providing the foundation for reliable patient care, administrative operations, and clinical decision-making processes. 